{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport * as helpers from \"./helpers\";\nexport default function createCompatNavigationProp(navigation, state, context, _isFirstRouteInParent) {\n  var _state$params;\n\n  context.parent = context.parent || {};\n  context.subscriptions = context.subscriptions || {\n    didFocus: new Map(),\n    didBlur: new Map(),\n    refocus: new Map()\n  };\n  return _objectSpread(_objectSpread(_objectSpread({}, navigation), Object.entries(helpers).reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        name = _ref2[0],\n        method = _ref2[1];\n\n    if (name in navigation) {\n      acc[name] = function () {\n        return navigation.dispatch(method.apply(void 0, arguments));\n      };\n    }\n\n    return acc;\n  }, {})), {}, {\n    original: navigation,\n    addListener: function addListener(type, callback) {\n      var unsubscribe;\n\n      switch (type) {\n        case 'willFocus':\n          unsubscribe = navigation.addListener('focus', callback);\n          break;\n\n        case 'willBlur':\n          unsubscribe = navigation.addListener('blur', callback);\n          break;\n\n        case 'didFocus':\n          {\n            var listener = function listener() {\n              if (navigation.isFocused()) {\n                callback();\n              }\n            };\n\n            unsubscribe = navigation.addListener('transitionEnd', listener);\n            context.subscriptions.didFocus.set(callback, unsubscribe);\n            break;\n          }\n\n        case 'didBlur':\n          {\n            var _listener = function _listener() {\n              if (!navigation.isFocused()) {\n                callback();\n              }\n            };\n\n            unsubscribe = navigation.addListener('transitionEnd', _listener);\n            context.subscriptions.didBlur.set(callback, unsubscribe);\n            break;\n          }\n\n        case 'refocus':\n          {\n            var _listener2 = function _listener2() {\n              if (navigation.isFocused()) {\n                callback();\n              }\n            };\n\n            unsubscribe = navigation.addListener('tabPress', _listener2);\n            context.subscriptions.refocus.set(callback, unsubscribe);\n            break;\n          }\n\n        case 'action':\n          throw new Error(\"Listening to 'action' events is not supported.\");\n\n        default:\n          unsubscribe = navigation.addListener(type, callback);\n      }\n\n      var subscription = function subscription() {\n        return unsubscribe();\n      };\n\n      subscription.remove = unsubscribe;\n      return subscription;\n    },\n    removeListener: function removeListener(type, callback) {\n      context.subscriptions = context.subscriptions || {};\n\n      switch (type) {\n        case 'willFocus':\n          navigation.removeListener('focus', callback);\n          break;\n\n        case 'willBlur':\n          navigation.removeListener('blur', callback);\n          break;\n\n        case 'didFocus':\n          {\n            var unsubscribe = context.subscriptions.didFocus.get(callback);\n            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();\n            break;\n          }\n\n        case 'didBlur':\n          {\n            var _unsubscribe = context.subscriptions.didBlur.get(callback);\n\n            _unsubscribe === null || _unsubscribe === void 0 ? void 0 : _unsubscribe();\n            break;\n          }\n\n        case 'refocus':\n          {\n            var _unsubscribe2 = context.subscriptions.refocus.get(callback);\n\n            _unsubscribe2 === null || _unsubscribe2 === void 0 ? void 0 : _unsubscribe2();\n            break;\n          }\n\n        case 'action':\n          throw new Error(\"Listening to 'action' events is not supported.\");\n\n        default:\n          navigation.removeListener(type, callback);\n      }\n    },\n    state: {\n      key: state.key,\n      routeName: state.name,\n      params: (_state$params = state.params) !== null && _state$params !== void 0 ? _state$params : {},\n\n      get index() {\n        var _state$state;\n\n        if (state.index !== undefined) {\n          return state.index;\n        }\n\n        console.warn(\"Looks like you are using 'navigation.state.index' in your code. Accessing child navigation state for a route is not safe and won't work correctly. You should refactor it not to access the 'index' property in the child navigation state.\");\n        return (_state$state = state.state) === null || _state$state === void 0 ? void 0 : _state$state.index;\n      },\n\n      get routes() {\n        var _state$state2;\n\n        if (state.routes !== undefined) {\n          return state.routes;\n        }\n\n        console.warn(\"Looks like you are using 'navigation.state.routes' in your code. Accessing child navigation state for a route is not safe and won't work correctly. You should refactor it not to access the 'routes' property in the child navigation state.\");\n        return (_state$state2 = state.state) === null || _state$state2 === void 0 ? void 0 : _state$state2.routes;\n      }\n\n    },\n    getParam: function getParam(paramName, defaultValue) {\n      var params = state.params;\n\n      if (params && paramName in params) {\n        return params[paramName];\n      }\n\n      return defaultValue;\n    },\n    isFirstRouteInParent: function isFirstRouteInParent() {\n      if (typeof _isFirstRouteInParent === 'boolean') {\n        return _isFirstRouteInParent;\n      }\n\n      var _ref3 = 'getState' in navigation ? navigation.getState() : navigation.dangerouslyGetState(),\n          routes = _ref3.routes;\n\n      return routes[0].key === state.key;\n    },\n    dangerouslyGetParent: function dangerouslyGetParent() {\n      var parent = 'getParent' in navigation ? navigation.getParent() : navigation.dangerouslyGetParent();\n\n      if (parent) {\n        return createCompatNavigationProp(parent, 'getState' in navigation ? navigation.getState() : navigation.dangerouslyGetState(), context.parent);\n      }\n\n      return undefined;\n    }\n  });\n}","map":{"version":3,"sources":["createCompatNavigationProp.tsx"],"names":["context","didFocus","didBlur","refocus","name","acc","navigation","method","original","addListener","unsubscribe","listener","callback","subscription","removeListener","state","key","routeName","params","console","getParam","paramName","isFirstRouteInParent","routes","dangerouslyGetParent","parent","createCompatNavigationProp"],"mappings":"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","sourcesContent":["import type {\n  NavigationState,\n  PartialState,\n  ParamListBase,\n  NavigationProp,\n  RouteProp,\n} from '@react-navigation/native';\nimport * as helpers from './helpers';\nimport type { CompatNavigationProp } from './types';\n\ntype EventName =\n  | 'action'\n  | 'willFocus'\n  | 'willBlur'\n  | 'didFocus'\n  | 'didBlur'\n  | 'refocus';\n\nexport default function createCompatNavigationProp<\n  NavigationPropType extends NavigationProp<ParamListBase>,\n  ParamList extends ParamListBase = NavigationPropType extends NavigationProp<\n    infer P,\n    any,\n    any,\n    any,\n    any\n  >\n    ? P\n    : ParamListBase\n>(\n  navigation: NavigationPropType,\n  state:\n    | (RouteProp<ParamList, keyof ParamList> & {\n        state?: NavigationState | PartialState<NavigationState>;\n      })\n    | NavigationState\n    | PartialState<NavigationState>,\n  context: Record<string, any>,\n  isFirstRouteInParent?: boolean\n): CompatNavigationProp<NavigationPropType> {\n  context.parent = context.parent || {};\n  context.subscriptions = context.subscriptions || {\n    didFocus: new Map<() => void, () => void>(),\n    didBlur: new Map<() => void, () => void>(),\n    refocus: new Map<() => void, () => void>(),\n  };\n\n  return {\n    ...navigation,\n    ...Object.entries(helpers).reduce<{\n      [key: string]: (...args: any[]) => void;\n    }>((acc, [name, method]: [string, Function]) => {\n      if (name in navigation) {\n        acc[name] = (...args: any[]) => navigation.dispatch(method(...args));\n      }\n\n      return acc;\n    }, {}),\n    original: navigation,\n    addListener(type: EventName, callback: () => void) {\n      let unsubscribe: () => void;\n\n      switch (type) {\n        case 'willFocus':\n          unsubscribe = navigation.addListener('focus', callback);\n          break;\n        case 'willBlur':\n          unsubscribe = navigation.addListener('blur', callback);\n          break;\n        case 'didFocus': {\n          const listener = () => {\n            if (navigation.isFocused()) {\n              callback();\n            }\n          };\n\n          // @ts-expect-error: this event may not exist in this navigator\n          unsubscribe = navigation.addListener('transitionEnd', listener);\n          context.subscriptions.didFocus.set(callback, unsubscribe);\n          break;\n        }\n        case 'didBlur': {\n          const listener = () => {\n            if (!navigation.isFocused()) {\n              callback();\n            }\n          };\n\n          // @ts-expect-error: this event may not exist in this navigator\n          unsubscribe = navigation.addListener('transitionEnd', listener);\n          context.subscriptions.didBlur.set(callback, unsubscribe);\n          break;\n        }\n        case 'refocus': {\n          const listener = () => {\n            if (navigation.isFocused()) {\n              callback();\n            }\n          };\n\n          // @ts-expect-error: this event may not exist in this navigator\n          unsubscribe = navigation.addListener('tabPress', listener);\n          context.subscriptions.refocus.set(callback, unsubscribe);\n          break;\n        }\n        case 'action':\n          throw new Error(\"Listening to 'action' events is not supported.\");\n        default:\n          unsubscribe = navigation.addListener(type, callback);\n      }\n\n      const subscription = () => unsubscribe();\n\n      subscription.remove = unsubscribe;\n\n      return subscription;\n    },\n    removeListener(type: EventName, callback: () => void) {\n      context.subscriptions = context.subscriptions || {};\n\n      switch (type) {\n        case 'willFocus':\n          navigation.removeListener('focus', callback);\n          break;\n        case 'willBlur':\n          navigation.removeListener('blur', callback);\n          break;\n        case 'didFocus': {\n          const unsubscribe = context.subscriptions.didFocus.get(callback);\n          unsubscribe?.();\n          break;\n        }\n        case 'didBlur': {\n          const unsubscribe = context.subscriptions.didBlur.get(callback);\n          unsubscribe?.();\n          break;\n        }\n        case 'refocus': {\n          const unsubscribe = context.subscriptions.refocus.get(callback);\n          unsubscribe?.();\n          break;\n        }\n        case 'action':\n          throw new Error(\"Listening to 'action' events is not supported.\");\n        default:\n          navigation.removeListener(type, callback);\n      }\n    },\n    state: {\n      key: state.key,\n      // @ts-expect-error\n      routeName: state.name,\n      // @ts-expect-error\n      params: state.params ?? {},\n      get index() {\n        // @ts-expect-error\n        if (state.index !== undefined) {\n          // @ts-expect-error\n          return state.index;\n        }\n\n        console.warn(\n          \"Looks like you are using 'navigation.state.index' in your code. Accessing child navigation state for a route is not safe and won't work correctly. You should refactor it not to access the 'index' property in the child navigation state.\"\n        );\n\n        // @ts-expect-error\n        return state.state?.index;\n      },\n      get routes() {\n        // @ts-expect-error\n        if (state.routes !== undefined) {\n          // @ts-expect-error\n          return state.routes;\n        }\n\n        console.warn(\n          \"Looks like you are using 'navigation.state.routes' in your code. Accessing child navigation state for a route is not safe and won't work correctly. You should refactor it not to access the 'routes' property in the child navigation state.\"\n        );\n\n        // @ts-expect-error\n        return state.state?.routes;\n      },\n    },\n    getParam<T extends keyof ParamList>(\n      paramName: T,\n      defaultValue: ParamList[T]\n    ): ParamList[T] {\n      // @ts-expect-error\n      const params = state.params;\n\n      if (params && paramName in params) {\n        return params[paramName];\n      }\n\n      return defaultValue;\n    },\n    isFirstRouteInParent(): boolean {\n      if (typeof isFirstRouteInParent === 'boolean') {\n        return isFirstRouteInParent;\n      }\n\n      const { routes } =\n        'getState' in navigation\n          ? navigation.getState()\n          : navigation.dangerouslyGetState();\n\n      return routes[0].key === state.key;\n    },\n    dangerouslyGetParent() {\n      const parent =\n        'getParent' in navigation\n          ? navigation.getParent()\n          : navigation.dangerouslyGetParent();\n\n      if (parent) {\n        return createCompatNavigationProp(\n          parent,\n          'getState' in navigation\n            ? navigation.getState()\n            : navigation.dangerouslyGetState(),\n          context.parent\n        );\n      }\n\n      return undefined;\n    },\n  } as any;\n}\n"]},"metadata":{},"sourceType":"module"}